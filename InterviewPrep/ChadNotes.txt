You Know this!
Terms and Definitions I need to know 

Primitive data types 
    byte, int, float, double, bool, char, (sometimes) string
    It's an object

Type vs Variable
    A type is a description 
    A variable is something that takes up memory.

    Constant: it doesn't change. 'Constant variable' is not a thing 
        global variables are constants 
    Identifiers: names that identify variable, functions, methods, and classes 

Scope:
    Describes the visibility, or validity, of an entity 
Lexical Scope (static scope): Determined by location of entity in code 

Types of variables: global, local and instance(class variable)

Operator Precedence! 
Python Precedence: (), **, +-, not, // %, +-(binary), <>=(comparisons), 
    == != (Equality), and, or, += -= (Assignment)

Type Conversion and type casting 
    Automatic: 
        int = int * int 
        float = float * float 
        float = int * float 
        double = float * double 
        Python / always returns a float 
    Manual:
        int = (int)(float * int) 

Conditional and relational operators 
    Conditional respond to bool 
    Relational operators evaluation boole results and bool vars, although not always bools
    Python: compares values (use 'is'), Java: compares references (use compareTo())
    Interning? Are you getting what you think you are? Shared objects for identical values or may 
                not happen

Types of Loops:
    counted, while, do-while, for-each 
    Sentinel: a special value that indicates, for example, a terminating condition

Function:
    Parameters: variables used in the declaration of the functions
    Arguments: the actual values passed into the function 
    Access Modifiers: visibility in the project 
    Signature: name, Parameters, return type, access modifiers. 

Parameters:
    by-value: copy the argument is made 
    by-reference: alias to the source argument 
    Java is by-value only. 
    Javascript is by-value only 
    Python is pass by-value ONLY (often called 'pass by object reference')

Function overloading:
    Same function name, parameter list differs in either or both number and types 
    Python uses default arguments to accomplish this; not actually overloading. 

Function:
    Standalone block of code 
    INvoke by it's name 
    Pure function: same input always gives the same output, does not modify anything 
        outside the function, no side effects; returns a result 

Method: 
    A block of code associated with an object (class); bound to an object 
    Invoked by name through an object instance 
    Data and behavior are bound together.
    Java ONLY has methods 

Program Stack 
    Region of memory that stores info about the program state, composed of stack frames 
    Last in, First out (LIFO)

Stack Frame 
    Local variables, function parameters, return address (instruction pointer),
        Stack pointer ( to keep track of previous frame calls)

HeaP
    Managed by OS, assigned to processes upon requests 
    When dynamically allocated a new object, memory comes from the heap 
    The heap is huge! This is where you get more memory 
    A garbage collector reclaims unused heap memory. Python uses this. 

Interpreted vs compiled:
    Interpreted: python
    Compiled: Java, C#
Just in time compilation (JIT): Python, java, javascript 
Improve performance (pycache?)
Ahead of time compilation (AOT): java for mobile

Static typed vs loosely typed:
    I already know this 

Class:
    blueprint for an object 
    Has properties, and behaviors (members)

Object:
    An instance of a class, has its own set of values for the class properties 
    Java/Javacript/Python objects are always allocated from the heap 

Visibility Modifiers:
    Allow, well, visibility of a class memeber (private)

Abstraction: 
    Hiding the implementation details and showing only the functionality 
    of an object 
    Abstract class: a class that cannot be instantiated, but can be subclassed 
    Abstract method: a method that is declared but not implemented
Encapsulation:
    Hiding implementation details from the user of a class
Inheritance: 
    A class can inherit properties and behaviors from another class 
    Single, multiple, multilevel, hierarchical, hybrid 
    Java does not support multiple inheritance 
    Python does support multiple inheritance 
    Javascript does not support multiple inheritance
Polymorphism:
    Static: generics or templates 
    Dynamic or Runtime: inheritance based, using overridden methods 
    Abstract class: Can't create an instance 
    The ability to present the same interface for different data types 
    Java: method overloading, method overriding 
    Python: duck typing 
    Javascript: duck typing 
    Overloading: same method name, different parameter list 
    Overriding: same method name, same parameter list, different implementation 
    Duck typing: if it walks like a duck, and quacks like a duck, it's a duck 
    (if it has the same method name, it's the same method)


Association: A general relationship that describes an activity between two classes 
    Students take a coures 
Aggregation: has a relationship. A class is composed of students and instructore 
    A wheel from a car, or an alternator
Composition: Cannot exist without the other. A cockpit in an airplane

Constructores and constructore chaining:
    Constructor at every level in inheritance is invoked, in order of specialized to general
Interface vs Class:
    Interface used to declare common behavior 
    Class is used to define common data and behavior

Time-complexity and space complexity 
    Time: how long it takes to run 
    Space: how much memory it takes to run 
    Big O notation:  O(1) O(n) O(n^2) O(log n) O(n log n) O(2^n) O(n!) 

Big Omega: Lower bound
Bit Theta: Tight bound. Average 

Sorting:
    Heap sort, merge sort, quick sort, bucket sort, radix sort. 

Fundamental data structures:
    Linked List, Stack, Queue, Binary Search Tree, AVL Tree, Red-Black Tree.

Self-Balancing Trees:
    AVL Tree, Red-Black Tree, Splay Tree, B-Tree, B+ Tree, 2-3 Tree, 2-3-4 Tree
    Main:
        AVL trees: 
        Splay trees: 
        Red-Black trees: 

Heaps:
    Heapify: 
    Binary Heap 
    Leftist Heap 
    Skew Heap: 
    Binomial Queue

Hashing: Map, Dictionary, symbol table, hash table, associated array
Hash function: transforms an object into a number 
    Equal objects return same hash code
    Fast, uniform distribution over range of table entries 

Hashing collisions:
    Separate chaining, linear probing, quadratic probing, double hashing. 

Graph Paths:
    Euler Path: a path using every edge of the graph exaclty once 
    Euler Circuit: an Euler path that returns to its start 
    Hamiltonian Path: a path that visits every vertex exactly once
    Hamiltonian Circuit: a Hamiltonian path that returns to its start

Graphs Traversals 
    Depth-first search 
    Breadth-first search
    Topological order


Dynamic Programming:
    Memoization: when solving a problem, store the results of subproblems
    So recursion, but remember it. 

    Solve all smaller problems first, to avoid recomputation 
    Not very easy, really hard!

Operating System Goals:
    Provide a user interface
    Allocated/manager resources 
    Control program execution 

OS interaction:
    System calls, system programs, system structure, system design. Like an API
    Types: process control, file management, device management, information maintenance, 
        communication, protection, command interpreter

OS structures:
    Monolithic, Layered, Microkernel, Modules, Hybrid. 
    A kernel is the core of the OS, and is the first thing to load.
    Hybrid: combines microkernel and monolithic

OS boot up:
    BIOS: basic input and output systems 
    UEFI - Unified Extensible Firmware Interface. mini OS, larger HD, GUI interface, Used GPT Partition

Process to represent a running program:
    Stack, heap, data, text. Need to pull into memory
    Data: references to the heap
    Text: the actual code

Process Control Block
    Process state, program counter, CPU registers, CPU scheduling info, memory management info, 
    accounting info, I/O status info
    OS uses this to manage processes 

Process States: 
    New, Ready, Running, Waiting, Terminated
    Context switching: when the OS switches from one process to another


Multiprogramming:
    Aka. Concurrency:
    Multiple process in memory at the same time waiting to be executined 
    ONly one process actually makes progress on the CPU at a time 
    Gives the illusion of multiple programs running at the same time.
    Switching really fast 
Multiprocessing:
    aka. Parallelism:
    Multiple processes running at the same time on multiple CPUs
    True parallelism

Threads:
    Thread vs Process:
        A process is a running program 
        A thread is associated with a process 
    Threads:
        Have their own stack and register values 
        Share code, data, resources 
    Thread types:
        User space 
        Kernel


Scheduling:
    Determining which process to move from the head to the running state 
    Preemptive: the OS can stop a process and move it to the ready state
    Non-preemptive: the process runs until it's done
    Pool of processes: the ready state
    Algorithms: FCFS, SJF, Priority, Round Robin, Multilevel Queue, Multilevel Feedback Queue
        Shortest Job First: not possible, good measure of performance
    Starving: a process that never runs 

Pre-Emption:
    The ability to remove a process form the CPU non-voluntarily
    Allows concurrency 
    Typically a time-out value determines when a process is pre-empted/removed 
Interrupts:
    Interrupts are signals to the CPU that some event has occurred 
    The CPU stops what it's doing and services the interrupt
    Hardware and software interrupts
    Hardware: external events
    Software: internal events

Synchronization 
    Interprocess Communication (IPC): 
        Message passing, shared memory, semaphores, monitors, message queues, pipes, sockets
    Race condition:
        When two or more processes are trying to access shared data at the same time
    Locking/Protection Data:
        Semaphores, mutexes, monitors, locks, barriers, condition variables

Memory Allocation 
    Processes are put into memory 
    Fragmentation:
        Internal fragmentation - process is given more space than what it needs 
        External Fragmenation - spaces in memory that are available, but not big enough 
    Memory utilization:
        Parts of memory that are not being used
    Virtual memory:
        A technique that allows the execution of processes that may not be completely in memory 
        Uses a page table to map virtual memory to physical memory 
        Paging: the process of dividing memory into fixed-size pages 
        Segmentation: the process of dividing memory into variable-size segments 
        Demand paging: only load pages into memory when they are needed 
        Page replacement: when a page is needed, but there is no room in memory 
        Thrashing: when the system spends more time swapping pages than executing processes

Security:
    CiA triad:
        confidentiality, integrity, availability
    Principle of Least Privilege






